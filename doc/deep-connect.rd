分散オブジェクトフレームワーク DeepConnect

== DeepConnect とは?

* 分散オブジェクトシステムを実現するためのフレームワーク
* fairyで採用

== DeepConnect ってなにしてくれるの?

ネットワーク越し、または、別のプロセス空間上のオブジェクトに対し、

* メッセージを送ったり、その結果を得ることができる機能を提供
* シンタックスが重要
  * remote_obj.message(arg1,...)
  * つまり、Rubyのメッセージ呼び出しの形式がそのまま使える
* もっと分かりやすく言えば、
  * drb の親戚です(^^;;

== 歴史

* 1996.11.18 [ruby-list: 1361] で初投稿
* 1997.01.31 [ruby-list: 2009] が最後の投稿
  * たぶん、モチベーションが下がった...
* 1999.07.14 drb 登場
  * そのころソースをいじった形跡があるので、少しやる気が出たらしい (^^;;
* 2001.06ごろ 別のコンセプトでまた考えている
* 2008.06.22 fairy で適用開始
  * DeepConnect と命名
  * ほとんど修正なしで動作。たぶん、1999年の時点で動作していたのだろう。
* 2010.10.22 githubに公開
* 2010.10.28 rubygems.org に公開

== DeepConnect入門 - イメージ
== DeepConnect入門 - (1)
* サーバー側（受けて側）
  * dc = DeepConnect::start(port)
  * # サービス開始
  * dc.export("name", obj)
  * # obj を name で参照できるように宣言
  * dc.export("RemoteArray", Array)
  * # クラスでもexportできる

== DeepConnect入門 - (2) 
* クライアント側（リクエスト出す側）
  * dc = DeepConnect::start
  * ds = dc.open_deepspace(相手addr, 相手port)
  * # 相手(のDeepSpace)と接続
  * remote_obj = deepspace.import("name")
  * # リモートオブジェクト(の参照)を取得。取っ掛かりのオブジェクトはimportする必要がある。 
  * RemoteArray = deepspace.import("RemoteArray")
  * # クラスも同様に取得可能

== DeepConnect入門 -- (3)
* あとは、だいたい普通にRubyのプログラムを組めばよい。
  * ret = remote_obj.req
  * # 戻り値もリモートオブジェクト（の参照）
  * remote_ary = RemoteArray.new
  * # サーバー側に配列が作られる。その参照を取得。
  * remote_ary.push “foo”
  * # さらにリモートオブジェクトにメッセージを送れる

== 特徴
* メソッドは参照渡し
* メソッドスペック
* Future型
* 分散GC
* 自動接続
* ShallowConnectモード 

== 特徴 - メソッドは参照渡し
* メソッドの引数も戻り値も参照渡し
* オブジェクト指向なんだから当たり前
* これによって既存プログラムの分散化が簡単に実現可能になる
* どのオブジェクトをどこに置くかを考えるだけでよくなる
* リモートオブジェクトとローカルのオブジェクトを区別なく利用可能になる
* 参照渡しであれば、基本的にコードの修正は必要ない
* 値(コピー)渡しはそうはいかない。

== 特徴 - メソッドは参照渡し
* fairyのmapの実装
    def basic_each(&block)
      @map_proc =BBlock.new(@block_source, @context, self)
      @input.each do |e|
        block.call @map_proc.yield(e)
      end
    end

* @inputが前段のフィルタになっている。これが、リモートのオブジェクト
  の場合もあるし、ローカルのオブジェクトの可能性もある。

* このように、リモート/ローカルのオブジェクトを区別なく使えることに
  より、オブジェクトの分散配置が自由に行えるようになる。これには、ク
  ラスをexportできるのが有効

== 特徴 - メソッドは参照渡し
* ただし、
  * Immutable なものと - これはよいとして
  * String は値（コピー）渡し - こちらは、、、
    * パフォーマンスを考えると。。。こういう選択になりました。
    * 文字列の場合、オブジェクトとして扱うよりは値がほしいことが多いの
      で、実用上はそれほど影響はない

* さらに、
  * オブジェクトとしてよりも、その値がほしい場合
    * 文字列は典型的な場合。
    * パフォーマンスを考えると、その他のオブジェクトでも、そういったこ
      とがないわけではない
  * 組み込みのメソッドの中にはリファレンスでは困ることが多い
    * 例) Array#& 
      * remote_ary & ary
      * このばあい、Array#&　はリファレンスオブジェクトとして理解し、
	リモートオブジェクトとして扱ってくれない。

== 特徴 - メソッドスペック
* メソッドに対し、MethodSpecを指定することによりその問題を回避
  * メソッド単位で参照以外を渡すことも可能になる。指定できるのは3種:
    * REF, VAL, DVAL - 参照、シャローコピー、ディープコピー
  * メソッド引数、戻り値、ブロック引数、ブロック戻り値に指定可能
    * def_method_spec(Object, "VAL to_a()")
    * def_method_spec(Array, :method=> :==, :args=> "VAL")
  * 組み込みメソッドに関しては、一通り定義済み
* # クラス単位での指定も出来るが、こちらのほうが便利

== 特徴 - Future型
* 非同期通信を実現するための手段として採用
  * メッセージを送った後、そのメッセージの結果を待たずに、実行を継続し、
    実際に必要になったときに、値があればそれを使い、なければ値が帰るま
    でまつ。

* 例
    v = DeepConnect::future{remote.req}
    # 処理を継続、vがFutureオブジェクト
    v.value			# 実際の値の取得
    v.messege		# Delegatorにもなっている

== 特徴 - 分散GC
* 他から参照されているオブジェクトは、GCされないようにしている。
  * 参照されなくなったら、GCの対象となるようになっている
* リファレンスカウント方式の分散GCを備えている。
  * 完全なGCではないのでごみが残ることもある。
  * かわりに、明示的なリリースメソッドを用意している

== 特徴 - 自動的な接続
* 必要があれば、自動的に接続する
  * 最初の取っ掛かりは、明示的接続が必要

    ds = dc.open_deepspace(相手addr, 相手port)
    remote_obj = deepspace.import("name")

  * 接続のされていない空間のオブジェクトの参照が渡されると自動的にその
   空間と接続するようになっている。
   * 複数プロセス間で参照のやり取りがある場合に有効

== 特徴 - ShallowConnect モード
* DeepConnectは、接続先に対してどんなメソッドも呼び出せてしまう。
  * DeepConnectの名前の由来
  * これはこれで、便利だが、危険なときも
* CORBA IDL的な指定ができるモードを用意
  * インターフェース宣言されたメソッドだけを利用可能に出来る
  * ただし、すべて宣言しなくてはならないので、かなり面倒。

== アーキテクチャ

== 実績
* fairyで採用
  * かなり激しい分散並列処理システムなので、ヘビーユーザーさまです
  * おかげさまで DeepConnect の品質が向上しました(^^;;
* fairyローカル版から、fairy分散版への修正は、
  * 5% ぐらいの修正で動作した。
  * ほんとんどがオブジェクトのexport/importの指定ぐらい。

== 注意事項
* あまりにも分散を無意識にできてしまうので、注意も必要
  * 構文上同じでも、ネットワーク通信はやっぱりコストがかかる。
    * 細かいメッセージは集約が必要
  * 不用意な戻り値。
* Array も参照が渡される
  * Rubyを理解していれば、だいじょうぶなはずだが、時々忘れることも(^^;;
  * 参照に対する == は、　equal? になっている。
  * Hash等でパフォーマンス上問題になるため。

